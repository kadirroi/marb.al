<html>

	<body>

		<canvas id="myCanvas" height="500" width="500"></canvas>

		<script type="text/javascript" src="glmatrix_lib/dist/gl-matrix.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			attribute vec3 aVertexPosition;
			attribute vec4 aVertexColor;
			uniform mat4 sclMatrix;
			uniform mat4 rotMatrix;
			varying vec4 vColor;

			void main(void){

				gl_Position = rotMatrix * sclMatrix * vec4(aVertexPosition, 1.0);
				vColor = aVertexColor;
			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			varying vec4 vColor;

			void main(void){

				gl_FragColor = vColor;

			}

		</script>

		<script type="text/javascript">

			window.addEventListener("keypress", rotate, false);	
			var rad = 0;
			var rad2 = 0;

			var canvas = document.getElementById("myCanvas");
			var gl = initGL(canvas);
				
				
			var rotMatrix;
			var vertexBufer;
			var indexBuffer;
			var colorBuffer;
			var indices=[1,2,3,7,6,5,0,4,5,1,5,6,6,7,3,0,3,7,0,1,3,4,7,5,1,0,5,2,1,6,2,6,3,4,0,7];
			var vertices;

			loadCube();
			


  			function loadCube() {
    			var request = new XMLHttpRequest();
    			request.open("GET", "cube.json");
    			request.onreadystatechange = function() {
      				if (request.readyState == 4) {
        				var data = JSON.parse(request.responseText);
						var x = [1,2,3,7,6,5,0,4,5,1,5,6,6,7,3,0,3,7,0,1,3,4,7,5,1,0,5,2,1,6,2,6,3,4,0,7];
	
						var colors = [
							1.0, 1.0, 1.0, 1.0, 
							1.0, 1.0, 1.0, 1.0, 
							1.0, 1.0, 1.0, 1.0, 
							0.0, 1.0, 0.0, 1.0,
							0.0, 1.0, 0.0, 1.0,
							0.0, 1.0, 0.0, 1.0,
							1.0, 0.0, 0.0, 1.0,
							1.0, 0.0, 0.0, 1.0
						];

						vertices = data.vertices;
						vertexBuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
						gl.bindBuffer(gl.ARRAY_BUFFER, null);

						indexBuffer = gl.createBuffer();
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(x), gl.STATIC_DRAW);


						gl.bindBuffer(gl.ARRAY_BUFFER, null);
						colorBuffer = gl.createBuffer();
						gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
						gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

						initShaders();

						gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.clearColor(0.0, 0.0, 0.0, 1.0);
						gl.enable(gl.DEPTH_TEST);
						gl.clear(gl.COLOR_BUFFER_BIT);
						gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
						gl.drawElements(gl.TRIANGLES, x.length, gl.UNSIGNED_SHORT, 0);

      				}
    			}
    			request.send();
  			}


			function initGL (canvas){
				var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
				for (var i=0; i<names.length; i++){
					try{
						var gl = canvas.getContext(names[i]);
					}
					catch (e){}
					if (gl)
						break;
				}

				if (gl == null){
					alert ("Could not initialise WebGL");
					return null;
				}
				
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
				return gl;
				
			}


			function initShaders(){
				
				var fragmentShader = createShader(gl, "fragmentShader");
				var vertexShader = createShader(gl, "vertexShader");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);
				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    				console.log("Shaders cannot be initialized");
  				}

				gl.useProgram(shaderProgram);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				var coordinate = gl.getAttribLocation(shaderProgram, "aVertexPosition");
				gl.vertexAttribPointer(coordinate, 3, gl.FLOAT, false, 0, 0);
				gl.enableVertexAttribArray(coordinate);

				gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
				var color = gl.getAttribLocation(shaderProgram, "aVertexColor");
				gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0);
				gl.enableVertexAttribArray(color);				

				var scaleMatrix = mat4.create();
				var idMatrix = mat4.create();

				scaleMatrix = mat4.scale(scaleMatrix, idMatrix, vec3.fromValues(0.3, 0.3, 0.3)); 

				var sclMatrix = gl.getUniformLocation(shaderProgram, "sclMatrix");
				gl.uniformMatrix4fv(sclMatrix, false, scaleMatrix);

				var rotationMatrix = mat4.create();
				rotMatrix = gl.getUniformLocation(shaderProgram, "rotMatrix");
				gl.uniformMatrix4fv(rotMatrix, false, rotationMatrix);	

			}

			function createShader(gl , id){
							
		
				var shaderScript = document.getElementById(id);
				
				if (!shaderScript)
					return null;
				
				var str = "";
				var k = shaderScript.firstChild;
				while (k){
					if (k.nodeType == 3){
						str += k.textContent;
					}
					k = k.nextSibling;
				}				

				var shader;
				if (shaderScript.type=="x-shader/x-fragment"){
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				}
				else
					if (shaderScript.type=="x-shader/x-vertex"){
						shader = gl.createShader(gl.VERTEX_SHADER);
					}
					else	
						return null;
				
				gl.shaderSource(shader, str);
				gl.compileShader(shader);
				
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.log ("shader compilation error");
	    			return null;
  				}

				console.log ("shaders loaded successfully");
				return shader;

			}

			function rotate(e){

				if (e.keyCode==38){
				var rot = mat4.create();
					rad2 += 0.2;
					mat4.rotateX(rot, mat4.create(), rad2);
					gl.uniformMatrix4fv(rotMatrix, false, rot);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.clearColor(0.0, 0.0, 0.0, 1.0);
						gl.enable(gl.DEPTH_TEST);
						gl.clear(gl.COLOR_BUFFER_BIT);
						gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
						gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);					

				}


				if (e.keyCode==40){
				var rot = mat4.create();
					rad2 -= 0.2;
					mat4.rotateX(rot, mat4.create(), rad2);
					gl.uniformMatrix4fv(rotMatrix, false, rot);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.clearColor(0.0, 0.0, 0.0, 1.0);
						gl.enable(gl.DEPTH_TEST);
						gl.clear(gl.COLOR_BUFFER_BIT);
						gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
						gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);					

				}

				if (e.keyCode==37){
					rad += 0.2;
		
					var rot = mat4.create();

					mat4.rotateY(rot, mat4.create(), rad);
					gl.uniformMatrix4fv(rotMatrix, false, rot);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.clearColor(0.0, 0.0, 0.0, 1.0);
						gl.enable(gl.DEPTH_TEST);
						gl.clear(gl.COLOR_BUFFER_BIT);
						gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
						gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
				}		
				if (e.keyCode==39){
					rad -= 0.2;

					var rot = mat4.create();

					mat4.rotateY(rot, mat4.create(), rad);
					gl.uniformMatrix4fv(rotMatrix, false, rot);
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
						gl.clearColor(0.0, 0.0, 0.0, 1.0);
						gl.enable(gl.DEPTH_TEST);
						gl.clear(gl.COLOR_BUFFER_BIT);
						gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
						gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
				}				

			}

		</script>

	</body>

</html>
